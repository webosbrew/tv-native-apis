#include <cv.h>
#include <cvaux.h>
#include <assert.h>
#include <stdio.h>
#include <highgui.h>


/* Function added to OpenCV to improve the capability to read and
write YUV420
* image files and convert in YUV 444 format.
*
*
* Author: Alberto - ***@ymail.com
* Not very optimized, but these funcions works fine!
*
* *** functions ***
* Load image YUV 420
* Save Image YUV 420
* New: Visualize YUV 420 images
*
*/


void check_error (int val) {
    if (val<0){
    fprintf(stderr, "Error load YUV file!\nPress ENTER to exit\n");
    getchar();
    exit(-1);
    }
}

/*
* Given a yuv 420 file stream extract the luma and chroma components,
the 2 chroma
* are then upsampled by a 2 factor, and return an image composed by 3
layer
* Y, U and V (format YUV 444, i.e. 3 byte for each pixel)
*
*/

IplImage * cvLoadImageYUV (char * name_file, int w, int h){


    IplImage *py, *pu, *pv, *pu_big, *pv_big, *image;
    int i, temp;

    FILE * pf= fopen(name_file, "rb");
    if (pf == NULL){
        fprintf(stderr, "Error open file %s\nPress ENTER to
        exit\n", name_file);
        getchar();
        exit(-1);
    }


    py = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 1);
    pu = cvCreateImage(cvSize(w/2,h/2), IPL_DEPTH_8U, 1);
    pv = cvCreateImage(cvSize(w/2,h/2), IPL_DEPTH_8U, 1);

    pu_big = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 1);
    pv_big = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 1);

    image = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 3);

    assert(py);
    assert(pu);
    assert(pv);
    assert(pu_big);
    assert(pv_big);
    assert(image);

    // Read Y
    for (i=0; i<w*h; i++){
        temp = fgetc(pf);
        check_error(temp);

        py->imageData[i] = (unsigned char) temp;
    }


    // Read U
    for (i=0; i<w*h/4; i++){
        temp = fgetc(pf);
        check_error(temp);

        pu->imageData[i] = (unsigned char) temp;
    }



    // Read V
    for (i=0; i<w*h/4; i++){
        temp = fgetc(pf);
        check_error(temp);

        pv->imageData[i] = (unsigned char) temp;
    }

    fclose(pf);

    cvResize(pu, pu_big, CV_INTER_LINEAR);
    cvResize(pv, pv_big, CV_INTER_LINEAR);



    cvReleaseImage(&pu);
    cvReleaseImage(&pv);



    cvMerge(py, pu_big, pv_big, NULL, image);

    cvReleaseImage(&py);
    cvReleaseImage(&pu_big);
    cvReleaseImage(&pv_big);



    return image;

}

/*
* Save image YUV 444 in YUV 420 format onto a file
*
*/

void cvSaveImageYUV (char * name_file, IplImage * img){

    IplImage * pu_small, *pv_small, *py, *pu, *pv;
    int w = img->width;
    int h = img->height;
    int i, temp;
    FILE * pf;

    py = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 1);
    pu = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 1);
    pv = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 1);
    pu_small = cvCreateImage(cvSize(w/2,h/2), IPL_DEPTH_8U, 1);
    pv_small = cvCreateImage(cvSize(w/2,h/2), IPL_DEPTH_8U, 1);

    assert(py);
    assert(pu);
    assert(pv);
    assert(pu_small);
    assert(pv_small);

    cvSplit(img, py, pu, pv, NULL);

    cvResize(pu, pu_small, CV_INTER_LINEAR);
    cvResize(pv, pv_small, CV_INTER_LINEAR);

    cvReleaseImage(&pu);
    cvReleaseImage(&pv);


    pf = fopen(name_file, "wb");
    if (pf == NULL){
        fprintf(stderr, "Error open file %s\nPress ENTER to exit\n", name_file);
        getchar();
        exit(-1);
    }

    for (i=0; i<w*h; i++){
        temp = fputc(py->imageData[i], pf);
        check_error(temp);
    }
    for (i=0; i<w*h/4; i++){
        temp = fputc(pu_small->imageData[i], pf);
        check_error(temp);
    }
    for (i=0; i<w*h/4; i++){
        temp = fputc(pv_small->imageData[i], pf);
        check_error(temp);
    }

    fclose(pf);
    cvReleaseImage(&py);
    cvReleaseImage(&pu_small);
    cvReleaseImage(&pv_small);

    return;
}


/*
* Show YUV 444 images after conversion in RGB color
*
*/


void cvShowImageYUV(char * window, IplImage * img, int waitTime) {

    int w = img->width;
    int h = img->height;
    IplImage * dst = cvCreateImage(cvSize(w,h), IPL_DEPTH_8U, 3);

    cvCvtColor(img,dst,CV_YCrCb2RGB);
    cvShowImage(window, dst);
    cvWaitKey(waitTime);

    cvReleaseImage(&dst);

    return;
}



int main (int argc, char **argv){


    IplImage * img = cvLoadImageYUV("aaa.yuv", 352, 288);

    cvNamedWindow("YUV", CV_WINDOW_AUTOSIZE);
    cvShowImageYUV("YUV", img, 0);

    cvSaveImage("our.bmp", img);

    cvDestroyWindow("YUV");
    cvReleaseImage(&img);

    fprintf(stderr, "Program %s Finished correctly\nPress ENTER to
    exit\n", argv[0]);
    getchar();

    return 0;
}

